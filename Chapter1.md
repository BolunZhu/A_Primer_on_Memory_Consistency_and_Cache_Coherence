# Chapter 1 Introduction to Consistency and Coherence


许多现代计算机系统和大多数多核芯片（芯片多处理器）在硬件上支持共享内存。在共享内存系统中，每个处理器核心可以对单个共享地址空间进行读写操作。这些设计追求各种优良性能，如高性能、低功耗和低成本。当然，如果不首先提供正确性，那么提供这些良好的属性是没有价值的。正确的共享内存在手摇水平上似乎很直观，但是，正如本文将要说明的那样，在定义共享内存系统的正确性意味着什么时，也存在一些微妙的问题，以及在设计正确的共享内存实现时的许多微妙的情况。此外，这些微妙之处必须掌握在硬件实现中，因为错误修复是昂贵的。即使是学者也应该掌握这些微妙之处，使他们提出的设计更有可能奏效。

我们和许多其他人发现将共享内存正确性分为两个子问题是有用的：consistency 和 coherence。计算机系统不需要进行这种分离，但我们发现这样分离有助于划分和克服复杂的问题，这种分离在许多实际的共享内存实现中普遍存在。

定义共享内存的正确性是consistency(一致性)的工作（内存一致性 memory consistency、内存一致性模型 memory consistency model或内存模型 memory model）。一致性定义提供有关load和store（或内存读写）以及它们如何作用于内存的规则。

理想情况下，一致性定义应该简单易懂。然而，定义共享内存的正确行为意味着什么，比定义单线程处理器内核的正确行为更为微妙。单处理器核的正确性准则将行为划分为一个正确的结果和许多不正确的选择。这是因为处理器的体系结构要求线程的执行将给定的输入状态转换为一个定义良好的输出状态，即使在一个无序的内核上也是如此。然而，共享内存一致性模型涉及多个线程的load和store，通常允许许多正确的执行，而不允许许多（更多）不正确的执行。

多个正确执行的可能性是由于ISA允许多个线程并发执行，通常有许多来自不同线程的指令的合法交织。大量正确的执行使以前确定一个执行是否正确的简单挑战复杂化了。然而，必须掌握一致性才能实现共享内存，在某些情况下，还要编写使用它的正确程序。

与consistency不同，coherence（或缓存一致性）对软件既不可见，也不需要。然而，作为支持一致性模型的一部分，绝大多数共享内存系统都实现了提供一致性的一致性协议。Coherence致力于使共享内存系统的缓存在功能上与单核系统中的缓存一样不可见。正确的一致性确保程序员不能通过分析加载和存储的结果来确定系统是否有缓存以及在哪里有缓存。这是因为正确的一致性确保，缓存永远有不同的行为（程序员仍然可以使用时间信息推断可能的缓存结构）.

在大多数系统中，coherence缓存一致性协议在提供consistency一致性方面起着重要作用。因此，即使consistency一致性是本入门课程的第一个主要主题，我们还是从第二章开始对coherence做一个简短的介绍。本章的目标是对coherence进行足够的解释，以了解consistency一致性模型如何与coherent caches交互，但不是探讨特定的coherence协议或实现，这些都是我们在第6章至第9章中本初级读物的第二部分才讨论的主题。在第二章中，我们使用单写多读（SWMR）不变量来定义coherence。SWMR要求，在任何给定的时刻，一个特定的内存位置要么在一个缓存中用于写（和读），要么在零到多个缓存中用于读。

----------------
## 1.1 Consistency(a.k.a., memory consistency,memory consistency model, memory model)

Consistency models 定义关于内存load/store的正确行为，不涉及到缓存一致性。

要理解一致性模型，可以从一些现实的例子出发，例如教务要修改学校的一门课程，教务先通知后台将课程信息修改，然后五分钟后通知所有学生查看课程信息。然而存在一种情况，后台在五分钟的时间内还没来得及修改课程信息，因此学生查看到的还是旧的信息。即便最后后台将信息修改成了新的值，还是会有一些学生以为自己要去旧的教室。

同样的行为也会发生在具有乱序处理、写buffer、prefetch和multiple cache banks的共享内存硬件上。因此我们需要定义共享内存的正确性--哪一种行为是被允许的--从而程序员可以知道将要发生的预期行为，实现者知道系统提供保证的极限边界在哪。

共享内存的正确性由consistency models(memory model 他们本质是一样的)指定。内存模型指定多线程程序在共享内存上被允许的行为。对于使用特定输入数据执行的多线程程序，内存模型指定动态load可能返回的值以及内存可能的最终状态。与单线程程序不同，可能有多个正确的行为，这使得理解内存模型更加微妙。

第3章介绍了内存一致性模型的概念，并介绍了最强大、最直观的一致性模型顺序一致性（SC）。本章从激发共享内存行为的需求开始，并精确定义了什么是内存一致性模型。接下来，它将深入研究直观的SC模型，该模型指出，多线程执行应该看起来像是每个组成线程的顺序执行的交错，就像线程在单核处理器上被时间多路复用一样。除此之外，本章还对SC进行了形式化描述，并探讨了如何以简单和积极的方式实现SC with conherence，最后以MIPS R10000为例进行了研究。

在第4章中，我们将超越SC，重点讨论x86和SPARC系统实现的内存一致性模型。这种一致性模型称为total store order（TSO），其动机是希望在将结果写入缓存之前使用先进先出的写缓冲区来保存已提交存储的结果。这种优化违反了SC，但它提供了足够的性能优势，可以激励体系结构定义TSO，从而实现这种优化。在本章中，我们将展示如何从SC的定义中定义TSO，TSO如何影响实现，以及SC和TSO的比较。

最后，第5章介绍了“松弛”或“弱”的内存一致性模型。它通过显示强模型中的大多数内存排序是不必要的来激励这些模型的。如果一个线程更新了10个数据项，然后更新了一个同步标志，程序员通常不关心这些数据项是否按顺序更新，而只关心在更新标志之前所有数据项都已更新。宽松的模型试图捕捉这种增加的顺序灵活性，以获得更高的性能或更简单的实现。在提供了这一动机之后，本章开发了一个称为XC的放松一致性模型，其中程序员只有在使用FENCE指令（例如，在最后一次数据更新之后但在标志写入之前）请求顺序时才能获得顺序。然后，本章扩展了前两章的形式来处理XC，并讨论了如何实现XC（在cores和一致性协议之间进行了大量的重新排序）。本章接着讨论了许多程序员可以避免直接考虑松弛模型的一种方法：如果他们添加足够的栅栏来确保他们的程序是无数据竞争的（DRF），那么大多数松弛模型都会出现SC。使用“SC for DRF”，程序员可以得到SC的（相对）简单的正确性模型和（相对）更高的模型XC的性能。对于那些想要更深入地解释的人，本章最后通过区分acquires和releases，讨论写原子性和因果性，转向商业实例（包括IBM的电源案例研究），并触及高级语言模型（java和C++）。

回到最初的例子，我们可以观察到教务、web管理员和文本消息系统的组合代表了一个非常弱的一致性模型。为了防止一个勤奋的学生到错误的房间，教务需要在她的电子邮件后执行围栏操作，以确保在发送短信前更新了课程信息。

---------------
## 1.2 Coherence(a.k.a., cache coherence)

除非小心，否则，如果多个参与者（例如，多个核心）可以访问一个数据的多个副本（例如，在多个缓存中），并且至少有一个访问是写操作，则可能会出现一致性问题。

考虑一个与内存一致性例子类似的例子。一名学生查看在线课程表，发现计算机架构课程正在152号房间举行（读取数据），并将这些信息复制到她的笔记本（缓存数据）。随后，大学注册官决定将班级搬到252房间，并更新在线时间表（写入数据）。学生的数据副本已经过时了，从而出现了coherence问题。如果她去152号房，她就找不到她的班了。

我们使用coherence protocol缓存一致性协议阻止对stale data过时数据（非一致性）的访问，一致性协议是由系统中的分布式的多个参与者集合共同实现的一组规则。一致性协议有许多变体，但遵循一些主题，如第6-9章所述。

第6章介绍了高速缓存一致性协议的总体情况，并为后面关于特定一致性协议的章节奠定了基础。本章讨论了大多数一致性协议共有的问题，包括缓存控制器和内存控制器的分布式操作以及常见的MOESI一致性状态：修改（M）、拥有（O）、独占（E）、共享（S）和无效（I）。重要的是，本章还介绍了我们的表驱动方法，用于呈现具有稳定（例如MOESI）和transient coherence states瞬变一致性状态的协议。在实际实现中需要瞬态变化，因为现代系统很少允许原子从一个稳定状态转换到另一个稳定状态（例如，状态无效的读取未命中将花费一段时间等待数据响应，然后才能进入共享状态）。一致性协议中的大部分实际复杂性隐藏在瞬态中，类似于处理器核心复杂度隐藏在微体系结构状态中的程度。

第7章介绍了snooping cache coherence protocols窥探缓存一致性协议，直到最近才主导了商业市场。在 hand-wave level，监听协议很简单。当缓存未命中时，核心的缓存控制器为共享总线进行仲裁并广播其请求。共享总线确保所有控制器以相同的顺序观察所有请求，因此所有控制器可以协调其各自的分布式操作，以确保它们保持全局一致的状态。然而，由于系统可能使用多个总线，而现代总线不能以原子方式处理请求，所以监听变得复杂起来。现代总线有等待仲裁的队列，可以发送单播、流水线延迟或无序的响应。所有这些特征导致更多的瞬间一致性状态。第7章以Sun UltraEnterprise E10000和IBMPOWER5的案例研究为结束。

第8章深入研究目录缓存一致性协议，它提供了扩展到更多处理器核心和其他参与者的承诺，而不是依赖广播的监听协议。有一个笑话说，计算机科学中的所有问题都可以通过某种程度的间接解决。目录协议支持这个笑话：缓存未命中请求下一级缓存（或内存）控制器的内存位置，该控制器维护一个目录，跟踪哪些缓存保存了哪些位置。基于请求的内存位置的目录条目，控制器向请求者发送响应消息，或者将请求消息转发给当前缓存内存位置的一个或多个参与者。每个消息通常有一个目的地（即，没有广播或多播），但是由于从一个稳定的一致性状态到另一个稳定的一致性状态的转换，可以生成与系统中参与者的数量成比例的消息数目的瞬态一致性状态。本章从一个基本目录协议开始，然后对其进行细化，以处理MOESI状态E和O、分布式目录、减少请求暂停、近似目录条目表示等。本章还探讨了目录本身的设计，包括目录缓存技术。本章以旧的SGI Origin 2000和较新的AMD HyperTransport、HyperTransport Assist和Intel QuickPath Interconnect（QPI）的案例研究作为结束。

第9章讨论coherence的一部分，但不是全部的高级主题。为了便于解释，前面关于一致性的章节故意将自己局限于解释基本问题所需的最简单的系统模型。第9章深入研究了更复杂的系统模型和优化，重点是snooping和目录协议共同存在的问题。初始主题包括处理指令缓存、多级缓存、直写缓存、转换查询缓冲区（TLB）、直接内存访问（DMA）、虚拟缓存和分层一致性协议。最后，本章将深入研究性能优化（例如，针对迁移共享和错误共享）以及直接维护具有token coherence令牌一致性的SWMR不变量

--------------------
## 1.3 A Consistency & Coherence quiz

下面的简单测试可以让读者知道自己对于consistency和coherence的知识是否足够，相关内容的阅读是否有必要。读者在继续阅读之前可以先尝试回答以下的问题。

### 问题1：
在一个保持顺序一致性SC的系统中，一个核必须按程序指定的顺序发出缓存一致性请求吗？答案在3.8节
### 问题2：
内存一致性模型指定了coherence transactions的合法顺序？3.8节
### 问题3：
执行一个read-modify-write指令（例如 test-and-set），一个核必须和其他核通信吗？3.9节
### 问题4：
在一个多核的Total Store Order系统中，线程可能会绕过写缓冲区，不管是哪个线程写的值吗？4.4节
### 问题5：
一个程序员编写与高级语言的一致性模型（例如Java）相关的同步代码时，需要考虑体系结构的内存一致性模型吗？5.9节
### 问题6：
在一个MSI snooping协议中，一个cache block只能是三种coherence状态中的一种。对吗？7.2节
### 问题7：
一个snooping缓存一致性协议需要核与核之间通过在bus上交流对吗？7.6节

------------
## 1.4 What this primer does not do

这本书被设计成9节75分钟的课程可以讲完，从2到9章节再加上一章进阶补充材料。

这本书并不涉及到：

- 同步。 不涉及到程序员为了同步使用的锁、栅栏、和其他同步手段。
- 商用松弛一致性模型。 本书并不会介绍所有的商业松弛一致性模型。
- 并行编程。 本书不讨论并行编程模型、方法、工具。


---------
# 译者总结
本章节主要讲解两个关键概念： consistency 和 coherence。

consistency定义共享内存的正确性，涉及到多个参与者对同一个共享内存进行读写的行为。consistency又可以称为memory consistency,memory consistency model, memory model。第3到第5章将介绍SC模型、TSO模型和其他松弛模型。

coherence指多个缓存(分布式系统)之间的一致性，涉及到同一个数据在分布式系统中如何达成一致的问题。coherence又称cache coherence即缓存一致性。第6到9章介绍缓存一致性以及两种缓存一致性协议：窥探缓存一致性和目录缓存一致性。最后介绍了缓存一致性中的一些更加细节的内容。

在阅读本书前，读者可以尝试回答1.3中的问题，看看自己对于一致性到底理解多少。